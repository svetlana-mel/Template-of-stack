# Лабораторная работа 3 <br>Шаблоны классов

## Постановка задачи
### Часть 1
Необходимо создать шаблон класса-контейнера "Стек элементов". В данном шаблоне реализовать конструкторы, деструктор, операции ввода-вывода, операцию присваивания.

Перегрузить следующие операции:
- Инициализация стека
- Помещение элемента в стек
- Удаление элемента из стека
- Определение верхнего элемента без его удаления
- Определение размера очереди
- Проверка на пустоту

Создать объекты данного класса для стандартных типов (int, float, double)
Написать тестирующую программу для проверки всех операций контейнера. Контейнер содержит элементы стандартных типов.

### Часть 2
Необходимо реализовать пользовательский класс Pair (пара чисел). Пара должна быть представлена двумя полями: типа int для первого числа и типа double для второго. Первое число при выводе на экран должно быть отделено
от второго числа двоеточием. 

Перегрузить все необходимые операции для данного класса. 
Создать объект класса "Стек элементов" для элементов пользовательского типа.
Написать аналогичную тестирующую программу для объекта класа.
## Описание класса-контейнера

Класс-контейнер реализует модель стека. Стек - это абстрактный тип данных, работающий по принципу "последний зашел - первый вышел". Все элементы стека складываюся в общую `стопку` и чтобы достать первый положенный в стек элемент необходимо достать все элементы после(сверху) него.

## Определение класса-контейнера
Класс-контейнер содержит поля: длина стека и указатель на динамически выделенную память под хранение элементов данного стека.
```cpp
class Stack {
private:
	int length_;
	Type* stack_;
```
В данном классе реализованы деструктор и 2 вида конструкторов: без параметров и с 1 параметром - длиной стека.
```cpp
public:
    Stack() : length_{ 0 }, stack_{ nullptr }{};
	Stack(int n) {
		if (n < 0) { throw std::exception("Stack length less than 0"); };
		if (n == 0) { throw std::exception("0 is not avaliable parametr in the Stack constructor"); };
		stack_ = new Type[n];
		length_ = n;
	}
	~Stack() {
		delete[] stack_;
	}
```
Реализованы методы:
- иннициализация стека
```cpp
    Stack<Type>& init(int n, Type* arr) {
		if (n < 0) { throw std::exception("Stack length less than 0"); };
		if (length_ != 0) { throw std::exception("Init function is not avaliable"); };
		stack_ = new Type[n];
		for (int i = 0; i < n; i++) {
			stack_[i] = arr[i];
		}
		length_ = n;
		return *this;
	}
```
- добавление элемента в конец
```cpp
	Stack<Type>& add(const Type& elem) {
		Type* s_new = new Type[length_ + 1];
		for (int i = 0; i < length_; i++) {
			s_new[i] = stack_[i];
		}
		s_new[length_] = elem;
		length_ += 1;
		Type* temporary = stack_;
		stack_ = s_new;
		delete[] temporary;
		return *this;
	}
```
- удаление элемента с конца
```cpp
	Stack<Type>& remove() {
		if (length_ < 1) { throw std::exception("Try to delete element from stack with 0 length."); }
		Type* s_new = new Type[length_ - 1];
		for (int i = 0; i < length_ - 1; i++) {
			s_new[i] = stack_[i];
		}
		length_ -= 1;
		Type* temporary = stack_;
		stack_ = s_new;
		delete[] temporary;
		return *this;
	}
```
- функция возврата последнего(верхнего) элемента стека
```cpp
	Type& last() {
		return stack_[length_ - 1];
	}
```
- функция возврата длины стека
```cpp
	int getLength() {
		return length_;
	}
```
- проверка на пустоту
```cpp
	bool isEmpty() {
		if (length_ == 0) {
			return false;
		}
		return true;
	}
```
- очищение стека
```cpp
	Stack<Type>& erase() {
		length_ = 0;
		delete[] stack_;
		stack_ = nullptr;
		return *this;
	}
```
Перегружены операторы `[]`, `<<`

## Описание пользовательского класса

Пользовательский класс (Point) - это пара чисел целочисленного типа и типа с плаваюшей точкой. 
Реализованы конструкторы для данного класса.
```cpp
public:
	Pair() {
		intP = 0;
		doubleP = 0;
	}
	Pair(int i, double d) {
		intP = i;
		doubleP = d;
	}
```
А также перегружены операторы `=`, `<<`

## Объяснение результатов работы программы

В результате получены разработанные класс-конструктор стек и пользовательский класс - пара чисел. Программа предоставляет возможность проверить работоспособность класса-конструктора как с базовыми типами, так и с объектами пользовательских классов на примере класса Pair.

## Контрольные вопросы
> 1. В чем смысл использования шаблонов?

Шаблоны функции или класса позволяют создать универсальный элемент функции/класса, который инициализируется (явно или неявно) некоторым типом, с которым мы хотим чтобы наша функция или класс работали.
Шаблоны позволяют сократить количество однотипного кода.

> 2. Что такое параметры шаблона функции? 

Опредляя шаблон, мы создаем функцию/класс без указанного типа. Если мы хотим создать объект класса, определенного шаблоном или функцию, в этом случае необходимо указать тип параметра шаблона.

**Параметр шаблона** - это некоторое ключевое слово(сивол), которое при инициализации будет заменено типом. 

Пример:
```cpp
template<class Type>
class Array
{
public:
    int m_length;
    Type *m_data;
    Array(int length) {
        m_data = new Type[length];
        m_length = length;
    }
}
```
В данном примере `Type` - параметр шаблона класса

> 3. Перечислите основные свойства параметров шаблона функции. 

Каждый праметр, определенный в списке параметров шаблона, должен быть использован хотя бы раз. Имена параметров в рамках одного шаблона не повторяются, но в разных шаблонах могут повторяться. 

> 4. Как записывать параметр шаблона? 

Параметр шаблона указывается в строке перед объявлением класса
```cpp 
template<class Type> 
```
Или перед объявлением шаблона функции возможен второй вариант записи:
```cpp 
template<typename Type> 
```
> 5. Можно ли перегружать параметризованные функции? 

При перегрузки шаблонных функций есть 2 варианта:

- Создание шаблона данной функции имеющего другое число параметров.
- Создание нешаблонной функции с тем же именем.

> 6. Перечислите основные свойства параметризованных классов. 

Память на параметризованный класс/функцию выделяется при инициализации. Если данный класс/функция не используются в коде кроме места объявления, то память на них выделяться не будет.

> 7. Все ли компонентные функции параметризованного класса являются
параметризованными? 

Параметризованный класс может содержать обычные функции (данные функции просто не будут взаиможействовать с параметризованными полями данного класса)

> 8. Являются ли дружественные функции, описанные в параметризованном
классе, параметризованными?

Дружественные функции должны быть объявлены как шаблоны. Пример:
```cpp
template <class Type> 
class MyClass {
    Type value_;
public:
    MyClass(const Type &value) : value_(value) {};

    template <class V>
    friend bool operator == (const MyClass<V>&, const MyClass<V>&);
};
```
> 9. Могут ли шаблоны классов содержать виртуальные компонентные
функции?

Шаблоны не могут содержать виртуальных методов. Шаблон != класс.

> 10. Как определяются компонентные функции параметризованных классов
вне определения шаблона класса?

Выше был приведен пример для дружественной функции. Ниже пример параметризованного метода:
```cpp
template <class Type> 
class MyClass {
  Type value_;
public:
    MyClass(const T &value) : value_(value) {};
  
    void print();
};

template <class T> 
void MyClass<T>::print() {
    std::cout << this->value_;
}
```
> 11. Что такое инстанцирование шаблона?

Создание объекта класса-шаблона с указанными значениями параметров шаблона (типов).

> 12. На каком этапе происходит генерирование определения класса по
шаблону?

Объект по шаблонного класса создается при компиляции.
